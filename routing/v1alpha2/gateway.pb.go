// Code generated by protoc-gen-go. DO NOT EDIT.
// source: routing/v1alpha2/gateway.proto

/*
Package istio_routing_v1alpha2 is a generated protocol buffer package.

It is generated from these files:
	routing/v1alpha2/gateway.proto
	routing/v1alpha2/route_rule.proto

It has these top-level messages:
	Gateway
	Server
	RouteRule
	Destination
	HTTPRoute
	TCPRoute
	HTTPMatchRequest
	DestinationWeight
	L4MatchAttributes
	HTTPRedirect
	HTTPRewrite
	StringMatch
	HTTPRetry
	CorsPolicy
	HTTPFaultInjection
	PortSelector
*/
package istio_routing_v1alpha2

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// The location of this service with respect to the service mesh.
type Server_Location int32

const (
	// Edge services are exposed outside the mesh, to external
	// users. Typical use case is that of exposing services via an ingress
	// gateway.
	Server_EDGE Server_Location = 0
	// Edge_internal services are visible at both the mesh edge and
	// inside the mesh. Sidecars will route requests directly to the
	// destination service without going to the gateway.
	Server_EDGE_INTERNAL Server_Location = 1
	// External services are hosted services (e.g. Google Maps) that may be
	// consumed by services in the mesh.
	Server_EXTERNAL Server_Location = 2
)

var Server_Location_name = map[int32]string{
	0: "EDGE",
	1: "EDGE_INTERNAL",
	2: "EXTERNAL",
}
var Server_Location_value = map[string]int32{
	"EDGE":          0,
	"EDGE_INTERNAL": 1,
	"EXTERNAL":      2,
}

func (x Server_Location) String() string {
	return proto.EnumName(Server_Location_name, int32(x))
}
func (Server_Location) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

// TLS modes enforced by the gateway
type Server_TLSOptions_TLSmode int32

const (
	// If set to "passthrough", the gateway will forward the connection to the
	// upstream server as is.
	Server_TLSOptions_PASSTHROUGH Server_TLSOptions_TLSmode = 0
	// If set to "simple", the gateway will secure connections with
	// standard TLS semantics (server certs only).
	Server_TLSOptions_SIMPLE Server_TLSOptions_TLSmode = 1
	// If set to "mutual", the gateway will use standard mTLS authentication.
	Server_TLSOptions_MUTUAL Server_TLSOptions_TLSmode = 2
	// Applicable only to external services. If set to originate, the
	// gateway implementation will initiate a HTTPS connection to the
	// service.
	Server_TLSOptions_ORIGINATE Server_TLSOptions_TLSmode = 3
)

var Server_TLSOptions_TLSmode_name = map[int32]string{
	0: "PASSTHROUGH",
	1: "SIMPLE",
	2: "MUTUAL",
	3: "ORIGINATE",
}
var Server_TLSOptions_TLSmode_value = map[string]int32{
	"PASSTHROUGH": 0,
	"SIMPLE":      1,
	"MUTUAL":      2,
	"ORIGINATE":   3,
}

func (x Server_TLSOptions_TLSmode) String() string {
	return proto.EnumName(Server_TLSOptions_TLSmode_name, int32(x))
}
func (Server_TLSOptions_TLSmode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{1, 1, 0}
}

// Gateway describes a load balancer operating at the edge of the mesh
// receiving incoming or outgoing HTTP/TCP connections. The specification
// describes a set of ports that should be exposed, the type of protocol to
// use, SNI configuration for the load balancer, etc.
//
// For example, the following gateway spec sets up a proxy to act as a load
// balancer exposing port 80 and 9080 (http), 443 (https), and port 2379
// (TCP) for ingress.  While Istio will configure the proxy to listen on
// these ports, it is the responsibility of the user to ensure that
// external traffic to these ports are allowed into the mesh.
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: Gateway
//     metadata:
//       name: my-gateway
//     spec:
//       servers:
//       - port:
//           number: 80
//           name: http
//         domains:
//         - uk.bookinfo.com
//         - eu.bookinfo.com
//         tls:
//           httpsRedirect: true # sends 302 redirect for http requests
//       - port:
//           number: 443
//           name: https
//         domains:
//         - uk.bookinfo.com
//         - eu.bookinfo.com
//         tls:
//           mode: simple #enables HTTPS on this port
//           serverCert: server.crt
//           clientCABundle: client.ca-bundle
//       - port:
//           number: 9080
//           name: http-wildcard
//         # no domains implies wildcard match
//       - port:
//           number: 2379 #to expose internal service via external port 2379
//           name: Mongo
//           protocol: MONGO
//
// The gateway specification above describes the L4-L6 properties of a load
// balancer. Routing rules can then be bound to a gateway to control
// the forwarding of traffic arriving at a particular domain or gateway port.
//
// The following sample route rule splits traffic for
// https://uk.bookinfo.com/reviews, https://eu.bookinfo.com/reviews,
// http://uk.bookinfo.com:9080/reviews, http://eu.bookinfo.com:9080/reviews
// into two versions (prod and qa) of an internal reviews service on port
// 9080. In addition, requests containing the cookie user: dev-123 will be
// sent to special port 7777 in the qa version. The same rule is also
// applicable inside the mesh for requests to the reviews.prod
// service. This rule is applicable across ports 443, 9080. Note that
// http://uk.bookinfo.com gets redirected to https://uk.bookinfo.com
// (i.e. 80 redirects to 443).
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: RouteRule
//     metadata:
//       name: bookinfo-rule
//     spec:
//       hosts:
//       - reviews.prod
//       - uk.bookinfo.com
//       - eu.bookinfo.com
//       gateways:
//       - my-gateway
//       - mesh # applies to all the sidecars in the mesh
//       http:
//       - match:
//         - headers:
//             cookie:
//               user: dev-123
//         route:
//         - destination:
//             port:
//               number: 7777
//             name: reviews.qa
//       - match:
//           uri:
//             prefix: /reviews/
//         route:
//         - destination:
//             port:
//               number: 9080 # can be omitted if its the only port for reviews
//             name: reviews.prod
//           weight: 80
//         - destination:
//             name: reviews.qa
//           weight: 20
//
// The following routing rule forwards traffic arriving at (external) port
// 2379 from 172.17.16.0/24 subnet to internal Mongo server on port 5555. This
// rule is not applicable internally in the mesh as the gateway list omits
// the reserved name "mesh".
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: RouteRule
//     metadata:
//       name: bookinfo-Mongo
//     spec:
//       hosts:
//       - Mongosvr #name of Mongo service
//       gateways:
//       - my-gateway
//       tcp:
//       - match:
//         - port:
//             number: 2379
//           sourceSubnet: "172.17.16.0/24"
//         route:
//         - destination:
//             name: mongo.prod
//
type Gateway struct {
	// REQUIRED: A list of server specifications.
	Servers []*Server `protobuf:"bytes,1,rep,name=servers" json:"servers,omitempty"`
}

func (m *Gateway) Reset()                    { *m = Gateway{} }
func (m *Gateway) String() string            { return proto.CompactTextString(m) }
func (*Gateway) ProtoMessage()               {}
func (*Gateway) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Gateway) GetServers() []*Server {
	if m != nil {
		return m.Servers
	}
	return nil
}

// Server describes the properties of the proxy on a given load balancer port.
// For example,
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: Gateway
//     metadata:
//       name: my-ingress
//     spec:
//       servers:
//       - port:
//           number: 80
//           protocol: HTTP2
//         domains:
//         - uk.bookinfo.com
//         - eu.bookinfo.com
//
// Another example
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: Gateway
//     metadata:
//       name: my-tcp-ingress
//     spec:
//       servers:
//       - port:
//           number: 27018
//           protocol: MONGO
//         domains:
//         - uk.bookinfo.com
//         - eu.bookinfo.com
//
// The following is an example of TLS configuration for port 443
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: Gateway
//     metadata:
//       name: my-ingress
//     spec:
//       servers:
//       - port:
//           number: 443
//           protocol: HTTP
//         domains:
//         - uk.bookinfo.com
//         - eu.bookinfo.com
//         tls:
//           mode: simple
//           serverCertificate: server.crt
//
// The following is an example of a gateway abstracting an external
// service. The caller is expected to access the service using
// http://maps.google.com:443
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: Gateway
//     metadata:
//       name: my-egress
//     spec:
//       servers:
//       - port:
//           number: 443
//           protocol: HTTP
//         domains:
//         - maps.google.com
//         tls:
//           mode: originate
//         location: external
//
type Server struct {
	// REQUIRED: The Port on which the proxy should listen for incoming
	// connections
	Port *Server_Port `protobuf:"bytes,1,opt,name=port" json:"port,omitempty"`
	// REQUIRED. A list of domains exposed by this gateway. While
	// typically applicable to HTTP services, it can also be used for TCP
	// services using TLS with SNI. Standard DNS wildcard prefix syntax
	// is permitted.
	//
	// RouteRules that are bound to a gateway must having a matching domain
	// in their default destination. Specifically one of the route rule
	// destination domains is a strict suffix of a gateway domain or
	// a gateway domain is a suffix of one of the route rule domains.
	Domains []string `protobuf:"bytes,2,rep,name=domains" json:"domains,omitempty"`
	// Set of TLS related options that govern the server's behavior. Use
	// these options to control if all http requests should be redirected to
	// https, and the TLS modes to use.
	Tls *Server_TLSOptions `protobuf:"bytes,3,opt,name=tls" json:"tls,omitempty"`
	// Optional: Indicates the location of the server with respect to the
	// other services in the mesh.
	Location Server_Location `protobuf:"varint,4,opt,name=location,enum=istio.routing.v1alpha2.Server_Location" json:"location,omitempty"`
}

func (m *Server) Reset()                    { *m = Server{} }
func (m *Server) String() string            { return proto.CompactTextString(m) }
func (*Server) ProtoMessage()               {}
func (*Server) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Server) GetPort() *Server_Port {
	if m != nil {
		return m.Port
	}
	return nil
}

func (m *Server) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

func (m *Server) GetTls() *Server_TLSOptions {
	if m != nil {
		return m.Tls
	}
	return nil
}

func (m *Server) GetLocation() Server_Location {
	if m != nil {
		return m.Location
	}
	return Server_EDGE
}

// Port describes the properties of a specific port of a service.
type Server_Port struct {
	// REQUIRED: A valid non-negative integer port number.
	Number uint32 `protobuf:"varint,1,opt,name=number" json:"number,omitempty"`
	// The protocol exposed on the port.
	// MUST BE one of HTTP|HTTPS|GRPC|HTTP2|MONGO|TCP.
	Protocol string `protobuf:"bytes,2,opt,name=protocol" json:"protocol,omitempty"`
	// Label assigned to the port.
	Name string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
}

func (m *Server_Port) Reset()                    { *m = Server_Port{} }
func (m *Server_Port) String() string            { return proto.CompactTextString(m) }
func (*Server_Port) ProtoMessage()               {}
func (*Server_Port) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

func (m *Server_Port) GetNumber() uint32 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *Server_Port) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *Server_Port) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Server_TLSOptions struct {
	// If set to true, the load balancer will send a 302 redirect for all
	// http connections, asking the clients to use HTTPS.
	HttpsRedirect bool `protobuf:"varint,1,opt,name=https_redirect,json=httpsRedirect" json:"https_redirect,omitempty"`
	// Optional: Indicates whether connections to this port should be
	// secured using TLS.  The value of this field determines how TLS is
	// enforced.
	Mode Server_TLSOptions_TLSmode `protobuf:"varint,2,opt,name=mode,enum=istio.routing.v1alpha2.Server_TLSOptions_TLSmode" json:"mode,omitempty"`
	// REQUIRED if mode == SIMPLE/MUTUAL. The name of the file holding the
	// server-side TLS certificate to use.  It is the responsibility of the
	// underlying platform to mount the certificate as a file under
	// /etc/istio/ingress-certs with the same name as the specified in this
	// field.
	ServerCertificate string `protobuf:"bytes,3,opt,name=server_certificate,json=serverCertificate" json:"server_certificate,omitempty"`
	// REQUIRED if mode == MUTUAL. To use mutual TLS for external clients,
	// specify the name of the file holding the CA certificate to validate
	// the client's certificate. It is the responsibility of the underlying
	// platform to mount the certificate as a file under
	// /etc/istio/ingress-certs with the same name as specified in this
	// field.
	ClientCaBundle string `protobuf:"bytes,4,opt,name=client_ca_bundle,json=clientCaBundle" json:"client_ca_bundle,omitempty"`
}

func (m *Server_TLSOptions) Reset()                    { *m = Server_TLSOptions{} }
func (m *Server_TLSOptions) String() string            { return proto.CompactTextString(m) }
func (*Server_TLSOptions) ProtoMessage()               {}
func (*Server_TLSOptions) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 1} }

func (m *Server_TLSOptions) GetHttpsRedirect() bool {
	if m != nil {
		return m.HttpsRedirect
	}
	return false
}

func (m *Server_TLSOptions) GetMode() Server_TLSOptions_TLSmode {
	if m != nil {
		return m.Mode
	}
	return Server_TLSOptions_PASSTHROUGH
}

func (m *Server_TLSOptions) GetServerCertificate() string {
	if m != nil {
		return m.ServerCertificate
	}
	return ""
}

func (m *Server_TLSOptions) GetClientCaBundle() string {
	if m != nil {
		return m.ClientCaBundle
	}
	return ""
}

func init() {
	proto.RegisterType((*Gateway)(nil), "istio.routing.v1alpha2.Gateway")
	proto.RegisterType((*Server)(nil), "istio.routing.v1alpha2.Server")
	proto.RegisterType((*Server_Port)(nil), "istio.routing.v1alpha2.Server.Port")
	proto.RegisterType((*Server_TLSOptions)(nil), "istio.routing.v1alpha2.Server.TLSOptions")
	proto.RegisterEnum("istio.routing.v1alpha2.Server_Location", Server_Location_name, Server_Location_value)
	proto.RegisterEnum("istio.routing.v1alpha2.Server_TLSOptions_TLSmode", Server_TLSOptions_TLSmode_name, Server_TLSOptions_TLSmode_value)
}

func init() { proto.RegisterFile("routing/v1alpha2/gateway.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 450 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x51, 0x41, 0x8b, 0x9b, 0x40,
	0x18, 0x5d, 0x13, 0x49, 0xcc, 0x97, 0x26, 0x75, 0xbf, 0xc3, 0x22, 0x39, 0x2c, 0x92, 0x52, 0x6a,
	0x0f, 0x75, 0x59, 0x4b, 0x69, 0xa1, 0x27, 0x9b, 0x4a, 0x36, 0xe0, 0x26, 0x61, 0x34, 0xd0, 0x9b,
	0x4c, 0xcc, 0x74, 0x57, 0x30, 0x8e, 0x8c, 0x93, 0x2d, 0xfd, 0x23, 0xfd, 0xb7, 0x85, 0xe2, 0xa8,
	0xbb, 0x97, 0xd2, 0xed, 0xed, 0xfb, 0xde, 0xbc, 0xf7, 0xbe, 0xe7, 0x13, 0x2e, 0x05, 0x3f, 0xc9,
	0xac, 0xb8, 0xbb, 0x7a, 0xb8, 0xa6, 0x79, 0x79, 0x4f, 0xbd, 0xab, 0x3b, 0x2a, 0xd9, 0x0f, 0xfa,
	0xd3, 0x2d, 0x05, 0x97, 0x1c, 0x2f, 0xb2, 0x4a, 0x66, 0xdc, 0x6d, 0x59, 0x6e, 0xc7, 0x9a, 0x2f,
	0x60, 0xb8, 0x6c, 0x88, 0xf8, 0x09, 0x86, 0x15, 0x13, 0x0f, 0x4c, 0x54, 0x96, 0x66, 0xf7, 0x9d,
	0xb1, 0x77, 0xe9, 0xfe, 0x5d, 0xe4, 0x46, 0x8a, 0x46, 0x3a, 0xfa, 0xfc, 0xb7, 0x0e, 0x83, 0x06,
	0xc3, 0x8f, 0xa0, 0x97, 0x5c, 0x48, 0x4b, 0xb3, 0x35, 0x67, 0xec, 0xbd, 0xfa, 0xb7, 0x83, 0xbb,
	0xe5, 0x42, 0x12, 0x25, 0x40, 0x0b, 0x86, 0x07, 0x7e, 0xa4, 0x59, 0x51, 0x59, 0x3d, 0xbb, 0xef,
	0x8c, 0x48, 0xb7, 0xe2, 0x67, 0xe8, 0xcb, 0xbc, 0xb2, 0xfa, 0xca, 0xf1, 0xed, 0x33, 0x8e, 0x71,
	0x18, 0x6d, 0x4a, 0x99, 0xf1, 0xa2, 0x22, 0xb5, 0x0a, 0x17, 0x60, 0xe4, 0x3c, 0xa5, 0x35, 0x62,
	0xe9, 0xb6, 0xe6, 0x4c, 0xbd, 0x37, 0xcf, 0x38, 0x84, 0x2d, 0x9d, 0x3c, 0x0a, 0x67, 0x6b, 0xd0,
	0xeb, 0xa4, 0x78, 0x01, 0x83, 0xe2, 0x74, 0xdc, 0x33, 0xa1, 0x3e, 0x6f, 0x42, 0xda, 0x0d, 0x67,
	0x60, 0xa8, 0x96, 0x53, 0x9e, 0x5b, 0x3d, 0x5b, 0x73, 0x46, 0xe4, 0x71, 0x47, 0x04, 0xbd, 0xa0,
	0x47, 0xa6, 0xe2, 0x8f, 0x88, 0x9a, 0x67, 0xbf, 0x7a, 0x00, 0x4f, 0x41, 0xf1, 0x35, 0x4c, 0xef,
	0xa5, 0x2c, 0xab, 0x44, 0xb0, 0x43, 0x26, 0x58, 0xda, 0xb4, 0x67, 0x90, 0x89, 0x42, 0x49, 0x0b,
	0x62, 0x00, 0xfa, 0x91, 0x1f, 0x98, 0xba, 0x30, 0xf5, 0xae, 0xff, 0xbb, 0x88, 0x7a, 0xac, 0x85,
	0x44, 0xc9, 0xf1, 0x1d, 0x60, 0xf3, 0xdf, 0x92, 0x94, 0x09, 0x99, 0x7d, 0xcf, 0x52, 0x2a, 0xbb,
	0x78, 0xe7, 0xcd, 0xcb, 0xe2, 0xe9, 0x01, 0x1d, 0x30, 0xd3, 0x3c, 0x63, 0x85, 0x4c, 0x52, 0x9a,
	0xec, 0x4f, 0xc5, 0x21, 0x67, 0xaa, 0xc8, 0x11, 0x99, 0x36, 0xf8, 0x82, 0x7e, 0x51, 0xe8, 0xdc,
	0x87, 0x61, 0x7b, 0x09, 0x5f, 0xc2, 0x78, 0xeb, 0x47, 0x51, 0x7c, 0x43, 0x36, 0xbb, 0xe5, 0x8d,
	0x79, 0x86, 0x00, 0x83, 0x68, 0x75, 0xbb, 0x0d, 0x03, 0x53, 0xab, 0xe7, 0xdb, 0x5d, 0xbc, 0xf3,
	0x43, 0xb3, 0x87, 0x13, 0x18, 0x6d, 0xc8, 0x6a, 0xb9, 0x5a, 0xfb, 0x71, 0x60, 0xf6, 0xe7, 0x1f,
	0xc0, 0xe8, 0xea, 0x47, 0x03, 0xf4, 0xe0, 0xeb, 0x32, 0x30, 0xcf, 0xf0, 0x1c, 0x26, 0xf5, 0x94,
	0xac, 0xd6, 0x71, 0x40, 0xd6, 0x7e, 0x68, 0x6a, 0xf8, 0x02, 0x8c, 0xe0, 0x5b, 0xbb, 0xf5, 0xf6,
	0x03, 0xd5, 0xf6, 0xfb, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x78, 0x50, 0x07, 0x1c, 0x05, 0x03,
	0x00, 0x00,
}
