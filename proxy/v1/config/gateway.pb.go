// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proxy/v1/config/gateway.proto

package istio_proxy_v1_config

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// TLS modes enforced by Envoy
type Server_TLSOptions_TLSmode int32

const (
	// If set to "passthrough", Envoy will forward the connection to the
	// upstream server as is.
	Server_TLSOptions_PASSTHROUGH Server_TLSOptions_TLSmode = 0
	// If set to "simple", Envoy will secure connections with
	// standard TLS semantics (server certs only).
	Server_TLSOptions_SIMPLE Server_TLSOptions_TLSmode = 1
	// If set to "mutual", Envoy will validate client's identity using
	// mTLS authentication.
	Server_TLSOptions_MUTUAL Server_TLSOptions_TLSmode = 2
)

var Server_TLSOptions_TLSmode_name = map[int32]string{
	0: "PASSTHROUGH",
	1: "SIMPLE",
	2: "MUTUAL",
}
var Server_TLSOptions_TLSmode_value = map[string]int32{
	"PASSTHROUGH": 0,
	"SIMPLE":      1,
	"MUTUAL":      2,
}

func (x Server_TLSOptions_TLSmode) String() string {
	return proto.EnumName(Server_TLSOptions_TLSmode_name, int32(x))
}
func (Server_TLSOptions_TLSmode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor2, []int{1, 1, 0}
}

// Gateway describes a load balancer operating at the edge of the mesh
// receiving incoming HTTP/TCP connections. The specification describes a
// set of ports that should be exposed outside the mesh, the type of
// protocol to use, SNI configuration for the load balancer, etc.
//
// For example, the following gateway spec sets up Envoy to act as a load
// balancer exposing port 80 and 9080 (http), 443 (https), and port 2379 (TCP).
// While Istio will configure Envoy to listen on these ports, it is the
// responsibility of the user to ensure that external traffic to these
// ports are allowed into the mesh.
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: Gateway
//     metadata:
//       name: my-gateway
//     spec:
//       servers:
//         http:
//           - port:
//               number: 80
//               name: http
//             domains:
//               - uk.bookinfo.com
//               - eu.bookinfo.com
//             tls:
//               httpsRedirect: true # sends 302 redirect for http requests
//           - port:
//               number: 443
//               name: https
//             tls:
//               mode: simple #enables HTTPS on this port
//             domains:
//               - uk.bookinfo.com
//               - eu.bookinfo.com
//           - port:
//               number: 9080
//               name: http-wildcard
//             # no domains implies wildcard match
//         tcp:
//           - port:
//               number: 2379 #to expose internal service via external port 2379
//               name: redis
//               protocol: REDIS
//       certs:
//       - domains:
//           - *.bookinfo.com
//         serverCert: server.crt
//         clientCABundle: client.ca-bundle
//
// The following route rule splits traffic for
// https://uk.bookinfo.com/reviews, https://eu.bookinfo.com/reviews,
// http://uk.bookinfo.com:9080/reviews, http://eu.bookinfo.com:9080/reviews
// into two versions (prod and qa) of an internal reviews service on port
// 9080. In addition, requests containing the cookie user: dev-123 will be
// sent to special port 7777 in the qa version. The same rule is also
// applicable inside the mesh for requests to the reviews.prod
// service. This rule is applicable across ports 443, 9080. Note that
// http://uk.bookinfo.com gets redirected to https://uk.bookinfo.com
// (i.e. 80 redirects to 443).
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: RouteRule
//     metadata:
//       name: bookinfo-rule
//     spec:
//       destination:
//         name: reviews.prod
//         domains:
//           - uk.bookinfo.com
//           - eu.bookinfo.com
//       gateway:
//         - my-gateway #apply at my-gateway as well as reviews.prod internally
//       http:
//         - match:
//             request:
//               headers:
//                 cookie:
//                   user: dev-123
//           route:
//           - destination:
//               port:
//                 number: 7777
//               name: reviews.qa
//         - match:
//             request:
//               headers:
//                 uri:
//                   prefix: /reviews/
//           route:
//           - destination:
//               port:
//                 number: 9080 # port can be omitted if its the only port for reviews
//               name: reviews.prod # can be omitted if its same as root destination.name
//             weight: 80
//           - destination:
//               name: reviews.qa
//             weight: 20
//
// The following routing rule forwards traffic arriving at (external)
// port 2379 from 172.17.16.* subnet to internal redis server on port 5555.
//
//     apiVersion: config.istio.io/v1alpha2
//     kind: RouteRule
//     metadata:
//       name: bookinfo-redis
//     spec:
//       destination:
//         port:
//           name: redis #only applies to ports named redis
//       gateway:
//         - my-gateway
//       tcp:
//         match:
//           tcp:
//             sourceSubnet:
//               - "172.17.16.0/24"
//         route:
//         - destination:
//             name: redis.prod
//
// By default, if there is no wildcard, HTTP requests for unknown domains
// or requests that have no matching route rule will respond with a
// 404. If a specific default behavior is desired at the ingress, add a
// route rule without any destination (implies wildcard) with the desired
// backend. For example, the following wildcard routing rule is applicable for
// port 9080
//
//     metadata:
//       name: default-ingress
//     spec:
//       destination:
//         port:
//           number: 9080
//       gateway:
//         - my-gateway #applies to
//       http:
//         route:
//         - destination:
//             name: homepage.prod
//
type Gateway struct {
	// REQUIRED: Details about the port on which the proxy listens and applies rules
	Servers []*Server `protobuf:"bytes,1,rep,name=servers" json:"servers,omitempty"`
	// Optional names of certificates for the server and the CA bundle to be used to validate
	// the client's certificate (if mTLS is to be used).
	Certs []*TLSConfig `protobuf:"bytes,2,rep,name=certs" json:"certs,omitempty"`
}

func (m *Gateway) Reset()                    { *m = Gateway{} }
func (m *Gateway) String() string            { return proto.CompactTextString(m) }
func (*Gateway) ProtoMessage()               {}
func (*Gateway) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

func (m *Gateway) GetServers() []*Server {
	if m != nil {
		return m.Servers
	}
	return nil
}

func (m *Gateway) GetCerts() []*TLSConfig {
	if m != nil {
		return m.Certs
	}
	return nil
}

// Server describes the properties of the proxy on a given load balancer port.
// For example,
//     metadata:
//       name: my-ingress
//     spec:
//       servers:
//       - port:
//           number: 80
//           protocol: HTTP2
//
// Another example
//     metadata:
//       name: my-tcp-ingress
//     spec:
//       servers:
//       - port:
//           number: 2379
//           protocol: redis
//
type Server struct {
	// REQUIRED: The Port on which Envoy should listen for incoming
	// connections
	Port *Server_Port `protobuf:"bytes,1,opt,name=port" json:"port,omitempty"`
	// A list of domains exposed by this gateway. While
	// typically applicable to HTTP services, it can also be used for TCP
	// services using TLS with SNI. Standard DNS wildcard prefix syntax
	// is permitted.
	//
	// RouteRules that are bound to a gateway must having a matching domain
	// in their default destination. Specifically one of the route rule
	// destination domains is a strict suffix of a gateway domain or
	// a gateway domain is a suffix of one of the route rule domains.
	Domains []string `protobuf:"bytes,2,rep,name=domains" json:"domains,omitempty"`
	// Set of TLS related options that govern the server's behavior. Use
	// these options to control if all http requests should be redirected to
	// https, and the TLS modes to use.
	Tls *Server_TLSOptions `protobuf:"bytes,3,opt,name=tls" json:"tls,omitempty"`
}

func (m *Server) Reset()                    { *m = Server{} }
func (m *Server) String() string            { return proto.CompactTextString(m) }
func (*Server) ProtoMessage()               {}
func (*Server) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

func (m *Server) GetPort() *Server_Port {
	if m != nil {
		return m.Port
	}
	return nil
}

func (m *Server) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

func (m *Server) GetTls() *Server_TLSOptions {
	if m != nil {
		return m.Tls
	}
	return nil
}

// Port describes the properties of a specific port of a service.
type Server_Port struct {
	// A valid non-negative integer port number.
	Number int32 `protobuf:"varint,1,opt,name=number" json:"number,omitempty"`
	// The protocol to communicate with the external services.
	// MUST BE one of HTTP|HTTPS|GRPC|HTTP2|MONGO|REDIS|TCP.
	Protocol string `protobuf:"bytes,2,opt,name=protocol" json:"protocol,omitempty"`
	// Name assigned to the port.
	Name string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
}

func (m *Server_Port) Reset()                    { *m = Server_Port{} }
func (m *Server_Port) String() string            { return proto.CompactTextString(m) }
func (*Server_Port) ProtoMessage()               {}
func (*Server_Port) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1, 0} }

func (m *Server_Port) GetNumber() int32 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *Server_Port) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *Server_Port) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Server_TLSOptions struct {
	// If set to true, the load balancer will send a 302 redirect for all
	// http connections, asking the clients to use HTTPS.
	HttpsRedirect bool `protobuf:"varint,1,opt,name=https_redirect,json=httpsRedirect" json:"https_redirect,omitempty"`
	// Optional: Indicates whether connections to this port should be
	// secured using TLS.  The value of this field determines how TLS is
	// enforced.
	Mode Server_TLSOptions_TLSmode `protobuf:"varint,2,opt,name=mode,enum=istio.proxy.v1.config.Server_TLSOptions_TLSmode" json:"mode,omitempty"`
}

func (m *Server_TLSOptions) Reset()                    { *m = Server_TLSOptions{} }
func (m *Server_TLSOptions) String() string            { return proto.CompactTextString(m) }
func (*Server_TLSOptions) ProtoMessage()               {}
func (*Server_TLSOptions) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1, 1} }

func (m *Server_TLSOptions) GetHttpsRedirect() bool {
	if m != nil {
		return m.HttpsRedirect
	}
	return false
}

func (m *Server_TLSOptions) GetMode() Server_TLSOptions_TLSmode {
	if m != nil {
		return m.Mode
	}
	return Server_TLSOptions_PASSTHROUGH
}

// TLSConfig describes the server-side TLS certificate and CA cert (for
// client authentication) for a particular domain exposed by the ingress load
// balancer. These domains are not resolved in any way. Its upto the end user
// to ensure that the DNS resolves these domains to the ingress load balancer
//
// For example, the following is an example of TLS configuration for port 443
//     metadata:
//       name: my-ingress
//       namespace: mynamespace
//     spec:
//       servers:
//       - port:
//           number: 443
//           protocol: HTTP
//         tls:
//           mode: simple
//       certs:
//       - domains:
//           - foo.bar.com
//         serverCertificatet: server.crt
//         clientCABundle: client.ca-bundle
//       - domains:
//           - example.com
//         serverCertificate: server.crt
//
type TLSConfig struct {
	// REQUIRED: A set of hostnames associated with the server
	// certificate. For wildcard hostname, use *
	Domains []string `protobuf:"bytes,1,rep,name=domains" json:"domains,omitempty"`
	// REQUIRED: The name of the file holding the server-side TLS certificate
	// to use.  It is the responsibility of the underlying platform to mount
	// the certificate as a file under /etc/istio/ingress-certs with the same
	// name as the specified in this field.
	ServerCertificate string `protobuf:"bytes,2,opt,name=server_certificate,json=serverCertificate" json:"server_certificate,omitempty"`
	// To use mutual TLS for external clients, specify the name of the file
	// holding the CA certificate to validate the client's certificate. It is
	// the responsibility of the underlying platform to mount the certificate
	// as a file under /etc/istio/ingress-certs with the same name as
	// specified in this field.
	ClientCaBundle string `protobuf:"bytes,3,opt,name=client_ca_bundle,json=clientCaBundle" json:"client_ca_bundle,omitempty"`
}

func (m *TLSConfig) Reset()                    { *m = TLSConfig{} }
func (m *TLSConfig) String() string            { return proto.CompactTextString(m) }
func (*TLSConfig) ProtoMessage()               {}
func (*TLSConfig) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2} }

func (m *TLSConfig) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

func (m *TLSConfig) GetServerCertificate() string {
	if m != nil {
		return m.ServerCertificate
	}
	return ""
}

func (m *TLSConfig) GetClientCaBundle() string {
	if m != nil {
		return m.ClientCaBundle
	}
	return ""
}

func init() {
	proto.RegisterType((*Gateway)(nil), "istio.proxy.v1.config.Gateway")
	proto.RegisterType((*Server)(nil), "istio.proxy.v1.config.Server")
	proto.RegisterType((*Server_Port)(nil), "istio.proxy.v1.config.Server.Port")
	proto.RegisterType((*Server_TLSOptions)(nil), "istio.proxy.v1.config.Server.TLSOptions")
	proto.RegisterType((*TLSConfig)(nil), "istio.proxy.v1.config.TLSConfig")
	proto.RegisterEnum("istio.proxy.v1.config.Server_TLSOptions_TLSmode", Server_TLSOptions_TLSmode_name, Server_TLSOptions_TLSmode_value)
}

func init() { proto.RegisterFile("proxy/v1/config/gateway.proto", fileDescriptor2) }

var fileDescriptor2 = []byte{
	// 412 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x52, 0xd1, 0x6a, 0xd4, 0x40,
	0x14, 0x35, 0xbb, 0x69, 0xd2, 0xdc, 0xc5, 0x35, 0x5e, 0x50, 0xc2, 0x42, 0x21, 0x04, 0x84, 0xbc,
	0x98, 0xb5, 0x11, 0x2a, 0xf8, 0x56, 0x57, 0x69, 0x85, 0xd4, 0x2e, 0x93, 0xec, 0x73, 0xc8, 0x26,
	0xd3, 0x3a, 0x90, 0x64, 0xc2, 0x64, 0xba, 0x5a, 0x1f, 0xfc, 0x0c, 0xff, 0xc2, 0x7f, 0x94, 0xcc,
	0x64, 0x5b, 0x05, 0x2d, 0xbe, 0x9d, 0x7b, 0xe6, 0x9c, 0x7b, 0x32, 0x67, 0x02, 0x47, 0x9d, 0xe0,
	0x5f, 0x6f, 0x97, 0xbb, 0xe3, 0x65, 0xc9, 0xdb, 0x2b, 0x76, 0xbd, 0xbc, 0x2e, 0x24, 0xfd, 0x52,
	0xdc, 0x46, 0x9d, 0xe0, 0x92, 0xe3, 0x33, 0xd6, 0x4b, 0xc6, 0x23, 0x25, 0x8a, 0x76, 0xc7, 0x91,
	0x16, 0x05, 0xdf, 0xc0, 0x3e, 0xd3, 0x3a, 0x7c, 0x03, 0x76, 0x4f, 0xc5, 0x8e, 0x8a, 0xde, 0x33,
	0xfc, 0x69, 0x38, 0x8b, 0x8f, 0xa2, 0xbf, 0x7a, 0xa2, 0x54, 0xa9, 0xc8, 0x5e, 0x8d, 0x27, 0x70,
	0x50, 0x52, 0x21, 0x7b, 0x6f, 0xa2, 0x6c, 0xfe, 0x3f, 0x6c, 0x59, 0x92, 0xae, 0x14, 0x22, 0x5a,
	0x1e, 0xfc, 0x98, 0x82, 0xa5, 0x77, 0xe1, 0x09, 0x98, 0x1d, 0x17, 0xd2, 0x33, 0x7c, 0x23, 0x9c,
	0xc5, 0xc1, 0x83, 0xc1, 0xd1, 0x9a, 0x0b, 0x49, 0x94, 0x1e, 0x3d, 0xb0, 0x2b, 0xde, 0x14, 0xac,
	0xd5, 0xe1, 0x0e, 0xd9, 0x8f, 0xf8, 0x16, 0xa6, 0xb2, 0xee, 0xbd, 0xa9, 0x5a, 0x18, 0x3e, 0xbc,
	0x30, 0x4b, 0xd2, 0xcb, 0x4e, 0x32, 0xde, 0xf6, 0x64, 0x30, 0x2d, 0x3e, 0x81, 0x39, 0x64, 0xe0,
	0x73, 0xb0, 0xda, 0x9b, 0x66, 0x4b, 0x85, 0xfa, 0xae, 0x03, 0x32, 0x4e, 0xb8, 0x80, 0x43, 0x55,
	0x6a, 0xc9, 0x6b, 0x6f, 0xe2, 0x1b, 0xa1, 0x43, 0xee, 0x66, 0x44, 0x30, 0xdb, 0xa2, 0xa1, 0x2a,
	0xd8, 0x21, 0x0a, 0x2f, 0x7e, 0x1a, 0x00, 0xf7, 0x19, 0xf8, 0x02, 0xe6, 0x9f, 0xa5, 0xec, 0xfa,
	0x5c, 0xd0, 0x8a, 0x09, 0x5a, 0xea, 0x6b, 0x1f, 0x92, 0xc7, 0x8a, 0x25, 0x23, 0x89, 0xef, 0xc1,
	0x6c, 0x78, 0x45, 0x55, 0xc2, 0x3c, 0x7e, 0xf5, 0xbf, 0x57, 0x18, 0xe0, 0xe0, 0x23, 0xca, 0x1d,
	0xc4, 0x60, 0x8f, 0x04, 0x3e, 0x81, 0xd9, 0xfa, 0x34, 0x4d, 0xb3, 0x73, 0x72, 0xb9, 0x39, 0x3b,
	0x77, 0x1f, 0x21, 0x80, 0x95, 0x7e, 0xbc, 0x58, 0x27, 0x1f, 0x5c, 0x63, 0xc0, 0x17, 0x9b, 0x6c,
	0x73, 0x9a, 0xb8, 0x93, 0xe0, 0x3b, 0x38, 0x77, 0x8f, 0xf5, 0x7b, 0xc5, 0xc6, 0x9f, 0x15, 0xbf,
	0x04, 0xd4, 0xbf, 0x40, 0x3e, 0xbc, 0x27, 0xbb, 0x62, 0x65, 0x21, 0xe9, 0x58, 0xc8, 0x53, 0x7d,
	0xb2, 0xba, 0x3f, 0xc0, 0x10, 0xdc, 0xb2, 0x66, 0xb4, 0x95, 0x79, 0x59, 0xe4, 0xdb, 0x9b, 0xb6,
	0xaa, 0xf7, 0x2d, 0xcd, 0x35, 0xbf, 0x2a, 0xde, 0x29, 0x76, 0x6b, 0xa9, 0x36, 0x5f, 0xff, 0x0a,
	0x00, 0x00, 0xff, 0xff, 0x0e, 0xfb, 0xf9, 0x2e, 0xd3, 0x02, 0x00, 0x00,
}
